using UnityEngine;
#if ENABLE_INPUT_SYSTEM
using UnityEngine.InputSystem;
#endif

/// <summary>
/// Simple WASD controller - transform-based movement only.
/// - W/S: move forward/back
/// - A/D: rotate left/right
/// 
/// Attach to the object you want to move, or set Target in inspector.
/// </summary>
public class WASDMovement : MonoBehaviour
{
	[Tooltip("If set, control this GameObject. If null, control the attached GameObject.")]
	public GameObject Target;

	[Tooltip("If Target is null, find this GameObject by name at Start.")]
	public string TargetName = "a5937a451209_a_square__low__box_shaped_ba_0_glb";

	[Tooltip("Movement speed (units per second)")]
	public float MoveSpeed = 5f;

	[Tooltip("Maximum rotation speed (degrees per second)")]
	public float MaxRotationSpeed = 120f;

	[Tooltip("Rotation acceleration")]
	public float RotationAcceleration = 180f;

	[Tooltip("Rotation friction/deceleration")]
	public float RotationFriction = 150f;

	public enum ForwardAxis
	{
		ZPlus,
		ZMinus,
		XPlus,
		XMinus,
		YPlus,
		YMinus
	}

	[Tooltip("Which local axis is forward")]
	public ForwardAxis Forward = ForwardAxis.ZPlus;

	[Tooltip("Gravity acceleration (units per second squared)")]
	public float GravityForce = 9.8f;

	[Tooltip("Distance to check for ground below")]
	public float GroundCheckDistance = 1.0f;

	[Tooltip("Collision detection distance (extends from object center)")]
	public float CollisionDistance = 0.15f;

	[Tooltip("Radius for collision detection")]
	public float CollisionRadius = 0.15f;

	[Tooltip("Acceleration when pressing movement keys")]
	public float Acceleration = 10f;

	[Tooltip("Friction/deceleration when no input")]
	public float Friction = 15f;

	[Tooltip("Maximum speed")]
	public float MaxSpeed = 15f;

	private float verticalVelocity = 0f;
	private Vector3 horizontalVelocity = Vector3.zero;
	private float rotationVelocity = 0f;
	private Rigidbody targetRb;

	void Start()
	{
		if (Target == null && !string.IsNullOrEmpty(TargetName))
		{
			Target = GameObject.Find(TargetName);
		}
		if (Target == null)
		{
			Target = gameObject;
		}
		Debug.Log($"[WASDMovement] Target: {Target.name}");
		
		// Ensure target has a Rigidbody - NON-kinematic so Unity handles collisions
		Rigidbody rb = Target.GetComponent<Rigidbody>();
		if (rb == null)
		{
			rb = Target.AddComponent<Rigidbody>();
		}
		rb.isKinematic = true; // TESTING: Disable physics to check if collisions cause floating
		rb.useGravity = false; // Not used with kinematic
		rb.constraints = RigidbodyConstraints.FreezeRotationX | RigidbodyConstraints.FreezeRotationZ;
		rb.linearDamping = 0f;
		rb.mass = 10f;
		rb.collisionDetectionMode = CollisionDetectionMode.ContinuousDynamic;
		rb.interpolation = RigidbodyInterpolation.Interpolate;
		targetRb = rb;
		
		// Ensure target has a collider
		if (Target.GetComponent<Collider>() == null)
		{
			Target.AddComponent<BoxCollider>();
			Debug.Log($"[WASDMovement] Added BoxCollider to {Target.name}");
		}
	}

	void Update()
	{
		if (Target == null) return;

		// Get WASD input
		bool w = false, s = false, a = false, d = false;

#if ENABLE_INPUT_SYSTEM
		var kb = Keyboard.current;
		if (kb != null)
		{
			w = kb.wKey.isPressed;
			s = kb.sKey.isPressed;
			a = kb.aKey.isPressed;
			d = kb.dKey.isPressed;
		}
#else
		w = Input.GetKey(KeyCode.W);
		s = Input.GetKey(KeyCode.S);
		a = Input.GetKey(KeyCode.A);
		d = Input.GetKey(KeyCode.D);
#endif

		// Get forward direction for this frame
		Vector3 forward = GetForwardVector();

	// Check for obstacles ahead
	bool blocked = false;
	if (w || s)
	{
		float move = w ? 1f : -1f;
		Vector3 checkDir = forward * move;
		
		// Check from current position
		Collider[] hits = Physics.OverlapSphere(Target.transform.position, 1.0f);			foreach (Collider col in hits)
		{
			// Ignore triggers and our own collider (including children)
			if (col.isTrigger) continue;
			
			// Check if this collider belongs to our own robot - check multiple ways
			bool isSelf = col.gameObject == Target || 
			              col.gameObject == gameObject ||
			              col.transform.IsChildOf(Target.transform) || 
			              Target.transform.IsChildOf(col.transform) ||
			              col.transform.IsChildOf(transform) ||
			              transform.IsChildOf(col.transform);
			
			if (!isSelf)
			{
				// Ignore floor - don't block on colliders below us
				if (col.bounds.max.y < Target.transform.position.y - 0.1f)
				{
					Debug.Log($"[WASDMovement] {col.name}: Ignoring (floor/below robot)");
					continue;
				}
				
				// Make sure the obstacle is actually in front, not just nearby
				Vector3 toObstacle = col.transform.position - Target.transform.position;
				float dot = Vector3.Dot(toObstacle.normalized, checkDir.normalized);
				
				Debug.Log($"[WASDMovement] {col.name}: dot={dot:F2} (>0.5=in front)");
				
				// Only block if obstacle is in the forward direction (dot > 0.5 means within ~60 degrees)
				Vector3 toObst = col.transform.position - Target.transform.position; float dist = toObst.magnitude; float dotVal = Vector3.Dot(toObst.normalized, checkDir.normalized); if (dotVal > 0.7f && dist < 0.6f)
				{
					blocked = true;
					Debug.Log($"[WASDMovement] BLOCKED by {col.name} (on {col.gameObject.name})");
					break;
				}
			}
		}			if (!blocked && Time.frameCount % 60 == 0)
			{
				Debug.Log($"[WASDMovement] Clear path. CheckPos: {checkPos}, Found {hits.Length} colliders");
			}
		}

	// Apply acceleration/deceleration to horizontal velocity
	if ((w || s) && !blocked)
	{
		float move = w ? 1f : -1f;
		Vector3 inputDir = forward * move;
		
		// Accelerate toward input direction
		horizontalVelocity = Vector3.Lerp(horizontalVelocity, inputDir * MaxSpeed, Acceleration * Time.deltaTime);
	}
	else
	{
		// Apply friction when no input OR when blocked
		if (blocked)
		{
			// Stop immediately when blocked
			horizontalVelocity = Vector3.zero;
		}
		else
		{
			// Gradual friction when no input
			horizontalVelocity = Vector3.Lerp(horizontalVelocity, Vector3.zero, Friction * Time.deltaTime);
		}
	}	// Check if on ground
	bool isOnGround = CheckGroundBelow();

		// Apply gravity (downward) - but stop at ground
		if (isOnGround)
		{
			if (verticalVelocity < 0)
				verticalVelocity = 0; // Stop falling when on ground
		}
		else
		{
			verticalVelocity -= GravityForce * Time.deltaTime;
		}

		// Rotation
		if (a || d)
		{
			float turn = a ? -1f : 1f;
			// Accelerate rotation
			rotationVelocity = Mathf.Lerp(rotationVelocity, turn * MaxRotationSpeed, RotationAcceleration * Time.deltaTime);
		}
		else
		{
			// Apply rotation friction
			rotationVelocity = Mathf.Lerp(rotationVelocity, 0f, RotationFriction * Time.deltaTime);
		}
	}

	void FixedUpdate()
	{
		// Apply movement as velocity to rigidbody
		if (targetRb != null)
		{
			// Use MovePosition for kinematic rigidbody
			Vector3 newPos = Target.transform.position + horizontalVelocity * Time.fixedDeltaTime;
			targetRb.MovePosition(newPos);
			
			// Apply rotation
			Quaternion deltaRot = Quaternion.Euler(0f, rotationVelocity * Time.fixedDeltaTime, 0f);
			targetRb.MoveRotation(targetRb.rotation * deltaRot);
		}
	}

	bool CheckGroundBelow()
	{
		Vector3 rayStart = Target.transform.position;
		Vector3 rayDirection = Vector3.down;

		// Cast a ray downward
		if (Physics.Raycast(rayStart, rayDirection, GroundCheckDistance))
		{
			return true;
		}
		return false;
	}

	bool CheckGroundAtPosition(Vector3 position)
	{
		if (Physics.Raycast(position, Vector3.down, GroundCheckDistance))
		{
			return true;
		}
		return false;
	}

	Vector3 SnapToGround()
	{
		Vector3 pos = Target.transform.position;
		RaycastHit hit;
		
		if (Physics.Raycast(pos, Vector3.down, out hit, GroundCheckDistance))
		{
			// Move object to just above the surface
			pos.y = hit.point.y;
		}
		
		return pos;
	}

	Vector3 GetForwardVector()
	{
		switch (Forward)
		{
			case ForwardAxis.ZPlus: return Target.transform.forward;
			case ForwardAxis.ZMinus: return -Target.transform.forward;
			case ForwardAxis.XPlus: return Target.transform.right;
			case ForwardAxis.XMinus: return -Target.transform.right;
			case ForwardAxis.YPlus: return Target.transform.up;
			case ForwardAxis.YMinus: return -Target.transform.up;
			default: return Target.transform.forward;
		}
	}
}